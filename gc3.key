##################################################################
#								 #
# MS-DOS/UNIX key definition file for Gram's Commander v3.3	 #
#								 #
# Written by Graham Wheeler. Last modified 30-6-94		 #
#								 #
##################################################################

IF_ANY

# Dummy function that just effectively declares some global variables

DeclareGlobals
{
	# no globals to declare	
}

# Things to do at the end before exiting.

Terminate 
{
	# We make sure debugging isn't on, otherwise lots of debug 
	# info will be written upon startup.
	$debug = "n"
	# unlock the file view
	$lock = "0"
	# Clear some big vars that we don't need to save
	$message = ""
	$nameacts = ""
	$typeacts = ""
	$linebuff = ""
	if (access $mytemp "0")
		unlink $mytemp
	quit
}

# Issue a warning message 

warn($msg) 
{
	write "WARNING: $msg"
	beep
}

# Prompt for and get a key press

GetKeyPress 
{
	local $key;
	write "Press a key to return to Gram's Commander..."
	read $key 0
}

# Prompt for a response with a message $msg, saving the response in $rsp
# Returns 1 if the response was in the set of characters given by $set,
# or 0 if any other key was pressed.

getAnswer($msg,$rsp,$set) 
{
	local $myprompt = $msg;
	expand $myprompt # we mustn't expand $msg as it is not always
			# a variable but sometimes a string literal
	write $myprompt
	$rsp = ""
	if (read $rsp 1 and $rsp in $set) return 1
	else return 0
}

getYNanswer($msg,$rsp) 
{
	local $prompt = "$msg ? (y/n) ";
	return getAnswer($prompt,$rsp,"yYnN");
}

# This function is used to check and report that the viewer is on
# for functions that can't be used at such a time.

ViewCheck 
{
	if ($viewer) 
	{
		warn("Can't do this when file viewer is in use!")
		return 0
	}
}

# Prompt for and read a command $cmd of up to 80 chars, expand any variables,
# add a pager if the command ends with a pipe, clear the screen if $clear
# is yes, exec the command, get a keypress if $prompt is yes, and 
# reread the directories if $rescan is yes.
#
# ExecCmd is used for actions, and for commands after they have been
# processed by ExpandCommand. DoCommand prompts for a command and
# then calls ExpandCommand. The description above thus applies specifically
# to a call to DoCommand, but most of the work is done by the other 
# two routines.

ExecCmd($cmd,$rescan,$clear) 
{
	if ($clear) clear
	exec $cmd
	if ($rescan) rescan "3"
}

# ExpandCommand

ExpandCommand($com,$reread) 
{
	local $junk, $exceptions, $prog, $xnow, $cmd = $com, $len, $suf="";
	# first expand any vars in the read command...
	expand $cmd
	$len = length $cmd
	makepath $junk $cmd ""
	if (matches $cmd "cd " 3) 
	{
		# do it with our own internal cd command
		tail -3 $cmd
		makepath $junk $cmd ""
		cd $junk
		rescan "1"
IF_DOS
	# if DOS drive descriptor, cd to it. This is a workaround
	# for the fact that Borland's access() doesn't work for CD-ROMs, so
	# the typeof check below fails...

	} else if (matches $len "2" and matches $cmd ":" -1)
	{
		cd $junk
		rescan "1"
IF_ANY
	} else if (typeof $junk in {dir,container}) 
	{
		cd $junk
		rescan "1"
	} else {

		# We really need arrays here!

		if (matches $cmd $sufc1 -1)
		{
			head -1 $cmd
			$cmd = "$pref1 $cmd $suf1"
			$suf = $suf1
		}
		else if (matches $cmd $sufc2 -1)
		{
			head -1 $cmd
			$cmd = "$pref2 $cmd $suf2"
			$suf = $suf2
		}
		else if (matches $cmd $sufc3 -1)
		{
			head -1 $cmd
			$cmd = "$pref3 $cmd $suf3"
			$suf = $suf3
		}
		else if (matches $cmd $sufc4 -1)
		{
			head -1 $cmd
			$cmd = "$pref4 $cmd $suf4"
			$suf = $suf4
		}
IF_UNIX
		# if we are piping the output of commands via tee
		# so that we can review the output afterwards, then there
		# are some programs we don't want to do this with (essentially
		# most interactive programs such as vi, elm, etc). We keep 
		# a list of these in the rule file. This part of the code
		# checks if the current command matches an entry

		if ($saveOutput and not "|" in $suf) 
		{
			# Get the actual command
			$exceptions = $except
			$prog = $cmd
			split 1 "#w" $prog $prog # truncate after first whitespc
			# now work thru the exception list
			while (not matches $exceptions "") 
			{
				$xnow = $exceptions
				if (not split 1 ":" $xnow $exceptions) break
				strip $xnow
				if (matches $prog $xnow) break
			}
			# if not an exception, add the "| tee" stuff
			if (not matches $prog $xnow) 
				$cmd = "$cmd | tee $mytemp"
		}
IF_ANY
		ExecCmd($cmd,$reread,$clear)
	}
}

DoCommand($start)  
{
	local $cmd=$start;	
	write "Command? "
	if (read $cmd -80) ExpandCommand($cmd,"y")
}

#############################
# Load the rules file stuff #
#############################

fileErr($name) 
{
	beep
	echo "Cannot open file $name!"
	sleep 1
}

# Look for a pager, viewer or editor utility given an entry in the
# rule file. Saves the string to invoke the utility in $invoke.

findUtility($entry, $result, $dummy)
{
	local $name, $invoke;
	if (not matches $result "") return 0; # Don't use rules if already set
	$expand = "n"
	if ($entry in "$")
	{
		if (not matches $entry "") 
		{
			$expand = "y"
			$result = $entry
			return 1
		}
	} else
	{
		$name = $entry
		strip $name
		$expand = "y"
		split 1 "#w" $name $invoke
		$expand = "n"
		if (inpath $name)
		{
			if (matches $invoke "") $invoke = $name
			$result = $invoke
			$expand = "y"
			return 1			
		}
	}
	$expand = "y"
	return 0
}

# Parse a list of entry fields in a rule, applying a command 
# to each component field in turn until the command returns
# true for one of them or they have al been done.

ParseAndApply($entry, $cmd, $arg1, $arg2)
{
	local $list, $field = "";
	# Go through the name pattern action list
	$expand = "n"
	$list = $entry
	while (not matches $list "")
	{
		$expand = "n"
		$field = $list
		if (not split 1 $ruleSep $field $list) break
		$expand = "y"
		if ("$cmd"($field, $arg1, $arg2))
			return 1
	}
	$expand = "y"
	if (not matches $field "") # last field
		if ("$cmd"($field, $arg1, $arg2))
			return 1
	return 0
}

loadArea($area, $item, $result) {
	local $tmparea = $area;
	expand $tmparea
	if (findArea $actionfile $tmparea)
		if (loadItem $item $result)
		{
IF_DEBUG
			echo "Set $item to $result"
			sleep 1
IF_ANY
		}
}

loadCommandArea($area,$cmd,$item,$result)
{
	local $junk, $dummy;
	$dummy = $item
	expand $dummy
	if (findArea $actionfile $area and
		loadItem $dummy $junk  and
		ParseAndApply($junk,$cmd,$result,$dummy))
	{
		echo "Set $dummy to $result"
IF_DEBUG
		sleep 1
IF_ANY
	}
}

loadTables($fname) 
{
	local $file, $junk;
	makepath $file $codepath $fname
	if (not open $file)
	{
		if (not inpath $fname $file or not open $file)
		{
			fileErr($file)
			return 0
		}
	}
	$actionfile = $file
	echo "Loading file $file"
IF_UNIX
	loadArea("UNIXExcept", "CantTee", $except)
IF_ANY
	loadCommandArea("$OS#Utils","findUtility","Editor",$editor)
	loadCommandArea("$OS#Utils","findUtility","Pager",$pager)
	loadCommandArea("$OS#Utils","findUtility","Viewer",$viewprog)
	loadCommandArea("$OS#Utils","findUtility","Mailer",$mailread)
	loadCommandArea("$OS#Utils","findUtility","NewsReader",$newsread)
	loadArea("$OS#Actions", "NameActions",	$nameacts)
	loadArea("$OS#Actions", "TypeActions",	$typeacts)
	loadrules
}

ApplyProgram($prg, $caller) 
{
	local $cmd = $prg;
	$expand = "n"
	strip $prg
	$expand = "y"
IF_DEBUG
	echo "In applyProgram($prg,$caller)";sleep 1
IF_ANY
	# If it ends with a !, we strip it and enter the 
	# command line editor
	if (matches $cmd "!" -1) 
	{
		head -1 $cmd
		expand $cmd
		DoCommand($cmd)
	} else if (matches $cmd "@" -1) 
	{
		# If it ends with a @ it is an internal command
		head -1 $cmd
		strip $cmd
		"$cmd"
	} else 
	{
		expand $cmd
		echo $cmd
		if ($caller in "v")		# view
		{
			execcatch $cmd
			view $tempfile
		} else if ($caller in "ion")	# extract name, copy in/out
			execcatch $cmd
		else if ($caller in "a") 	# action
			exec $cmd
	}
}

# Apply the rules in the tables

ApplyRule($rule,$file,$caller)
{	
	local $cmd;
	strip $rule
	split 1 "#w" $rule $cmd # split at whitespace
	if (matches $file /$rule/)
	{
		ApplyProgram($cmd,$caller)
		return 1
	}
	else return 0
}

ApplyRules($namelist, $typelist, $file, $caller) 
{
	local $typeout;
	# Set up the $base variable
	$basename = $file
	split 1 "." $basename $suffix
	if (ParseAndApply($namelist,"ApplyRule",$file,$caller))
		return 1
	# Go through the `file' pattern action list
	if (not matches $typelist "")
	{
		execcatch "file $file"
		$typeout = $linebuff
		if (not matches $typeout "")
			if (ParseAndApply($typelist,"ApplyRule",$typeout,$caller))
				return 1
	}
	return 0
}

#########################################################
#							#
#	File name/type-dependent commands		#
#							#
#########################################################

FileDep 
{
	local $parent, $child, $path;
	if (matches $pFile "..")
	{
		# gc3 no longer positions the cursor at the 
		# old directory after a `cd ..';
		# it would be messy to do it now, so we do it here...
		$parent = $ppath
		split -1 $sep $parent $child
		makepath $path $ppath ".."
		cd $path # don't do a cd .. as this is a relative
			# path and has a working dir prepended 
			# instead of $ppath which may have a container name
		paint # force a reread now so the search will work
		search $child
		return 1
	}
	makepath $path $ppath $pfile
	if (typeof $path in {dir,container})
		if (cd $path) return 1
	if (not ApplyRules($nameacts, $typeacts, $pfile, "a")) 
	{
IF_UNIX
		if (typeof $pFile in {exec}) 
		{
			DoCommand("$pfile ")
			return 1
		}
IF_ANY
      		warn("No action associated with this file!")
	}
}

#################################################################
#								#
#		File selection commands				#
#								#
# Flip - Invert select state of file at cursor			#
# InvertSelection - Invert set of selected files		#
# SelectByPattern - Get a pattern and select matching files	#
# DeselectByPattern - Get a pattern and deselect matching files	#
#								#
#################################################################

Flip 
{
	if (marked $pFile) unmark $pFile
	else mark $pFile
	down
}

InvertSelection 
{
	local $fname;
	loop ($fname) 
	{
		if (marked $fname) unmark $fname
		else mark $fname
	}
}

# we use a global $pat for the next two so that the value is persistent

SelectByPattern 
{
	write "Pattern? "
	if (read $pat 60) mark /$pat/
}

DeselectByPattern 
{
	write "Pattern? "
	if (read $pat 60) unmark /$pat/
}


##############################################################
#							     #
#		File copying, moving and deleting	     #
#							     #
##############################################################

# Check if target exists and get overwrite confirmation

doCopy($src,$dest) 
{
	echo "Copying $src to $dest"
IF_DOS
	# Special handling for copying directories under DOS
	if (typeof $src in {dir}) # directory copy
	{
		# Make the destination directory, if necessary
		if (not access $dest "0") execcatch "mkdir $dest"
		# Do the copy using DOS' xcopy command
		execcatch "xcopy $src $dest /s"
		return 1
	}
	else 
IF_ANY
	if (copy $src $dest) return 1
	else return 0
}

doDelete($file) 
{
	local $tmp, $prompt, $tf;
	if (typeof $file in {dir}) 	# directory delete
	{
		execcatch "rmdir $file"
		echo $linebuff
		if (access $file "0") # delete failed => not empty
		{
			$prompt = "Directory $file not empty - confirm delete"
			if (getYNAnswer($prompt $tmp) and $tmp)
			{
IF_DOS
				execcatch "deltree /Y $file"
				echo $linebuff
IF_UNIX
				# We don't do execcatch in case there
				# are permissions problems needing interaction
				exec "rm -r $file"
IF_ANY
			}
		}
	} else 
	{
		# if $usetrash is on, then we copy the file to the
		# trash directory and update the trash index...
		if ($usetrash) 
		{
			# find an unused file name in the trash directory...
			do 
			{
				$tf = $random
				head 4 $tf
				$tmp = "$trashdir$sep$tf"
			}
			while (access $tmp "0")

			# update the index
IF_DOS
			append "$trashdir$sep#gc3trash.idx" "$tf $date $time $file#010#013" 
IF_UNIX
			append "$trashdir$sep#gc3trash.idx" "$tf $date $time $file#010" 
IF_ANY
			# move file to trash
			move $file $tmp
		}
		else unlink $file
	}
}

doMove($src,$dest)
{
	local $path, $name;
	echo "Moving $src to $dest"
IF_DOS
	if (typeof $src in {dir})
	{
		# if the dest is just a name with no path, we can
		# do a ren, else we must do a xcopy and deltree.
		$path = $dest
		split -1 $sep $path $name
		if ((matches $path $ppath) and (not access $dest "0"))
			execcatch "ren $src $dest" # rename directory
		else
		{
			if (doCopy($src,$dest))
			{
				rescan "3"; paint
				doDelete($src)
			}
		}
	}
	else
IF_ANY
		move $src $dest
}

# generic handler for copy, move and delete

BasicFileOp($act) 
{
	local $tmp, $fname, $dest, $src, $prompt, $mustRescan = "n",
		$rescanArg, $destpath;
	$confirm = "y"
	if ($act in "CM")
	{
		if ($act in "M") $rescanArg = "3"
		else $rescanArg = "2";
		if ( eval $pselcnt )
			write "$act $pSelSize bytes in $pSelCnt file(s) to "
		else if (typeof $pfile in {dir})
			write "$act directory $pFile to "
		else
			write "$act $pSize bytes in $pFile to "
		$dest = $spath
		if (not read $dest 80) return 0
		# the user may have entered a destination
		# directory or a destination file
		# We check for a directory...
IF_DOS
		# handle drive specs such as "C:"
		if (matches $dest /?:/)
		{
			$tmp = $ppath	# remember where we are
			cd $dest	# change to the dest drive
			$dest = $ppath	# get the cwd on the drive
			cd $tmp		# and restore where we were
		}
IF_ANY
		if (not matches $dest $spath)
			$rescanArg = "3"
		if (eval $pselcnt)
		{
			if (not typeof $dest in {container,dir})
			{
				echo "Destination is not a directory or container!"
				return 0
			}
			loop ($fname) 
			{
				if ((not marked $fname) or matches $fname "..")
					continue
				makepath $src $ppath $fname
				makepath $destpath $dest $fname
				if ($act in "M")
				{
					if (doMove($src,$destpath))
						$mustRescan = "y"
				}
				else if (doCopy($src,$destpath)) 
				{
					$mustRescan = "y"
					if ($deselect)
						unmark $fname
				}
			}
			echo "$act finished"
		}
		else
		{
			if (typeof $dest in {container,dir})
				makepath $destpath $dest $pFile
			else makepath $destpath $dest ""
			makepath $src $ppath $pfile
			if ($act in "Mm")
			{
				if (doMove($src,$destpath))
					$mustRescan = "y"
			} else if (doCopy($src,$destpath)) 
			{
				$mustRescan = "y"
				if ($deselect)
					unmark $fname
			}
		}
	} else
	{
		$rescanArg = "1"
		if ( eval $pselcnt ) 
		{
			$prompt = "Deleting $pSelSize bytes in $pSelCnt file(s) - confirm y/n? ";
			if (not getAnswer($prompt $tmp "yY")) return 0
			loop ($fname) 
			{
				if (matches $fname "..") continue
				if (marked $fname and not matches $fname "..")
				{
					makepath $src $ppath $fname
					if (doDelete($src)) $mustRescan = "y"
				}
			}
		} else if (not matches $pfile "..") {
			makepath $src $ppath $pfile
			if (doDelete($src)) $mustRescan = "y"
		}
	}
	if ($mustRescan)
	{
		if (matches $ppath $spath)
			rescan "3"
		else rescan "$rescanArg"
	}
}		

MoveFiles  	{ BasicFileOp("Moving")		}
CopyFiles  	{ BasicFileOp("Copying")	}
DeleteFiles	{ BasicFileOp("Deleting")	}

RenameFile 
{
	local $dest, $prompt;
	write "Rename $pFile to? "
	$dest = ""
	if (read $dest 40 and move $pFile $dest)
		rescan "1"
}

MakeDir 
{
	local $tmp;
	write "New directory name? "
	if (read $tmp 40) 
	{
		if (access $tmp "0") 
		{
			echo "$tmp exists!"
			return 1;
		}
		execcatch "mkdir $tmp"
		echo $linebuff
		rescan "1"
	}
}

##############################################################
#							     #
#		File viewing and editing		     #
#							     #
##############################################################

# CompareFiles is useful for making patches; I use it for creating
# the patches for gc3

CompareFiles 
{
	local $fname, $cdir = "";
	write "Compare path? "
	if (read $cdir 40) 
	{
		loop ($fname)
			if (marked $fname)
				exec "diff -c $cdir$sep$fname $fname > $fname.dif"
		rescan "1"
	}
}

ApplyOpToFiles($op) 
{
	local $fname, $cmd;
	if (eval $pselcnt)
	{
		$cmd = $op
		loop ($fname)
			if (marked $fname and typeof $fname in {reg,exec,link})
				$cmd = "$cmd $fname"
		if (not matches $op $cmd)
			exec $cmd
		else beep
	} else 
	{
		if (typeof $pFile in {reg, exec, link})
			exec "$op $pFile"
		else beep
	}
}

EditFiles	{ ApplyOpToFiles($editor)	}

# We used to view selected files, if any - now we just view the
# file at the cursor (like Norton), as this behaviour is preferable.

#PageFiles	{ ApplyOpToFiles($viewprog)	}

PageFiles	
{
	if (typeof $pFile in {reg, exec, link}) exec "$viewprog $pFile"
	else beep;
}

ProcFiles  
{
	local $cmd, $pref, $suf, $fname, $cmd2, $len, $front, $back;
	write "Command (or placeholders; currently $basehold$extenshold)? "
	if (read $cmd -80) 
	{
		$len = length $cmd
		if (matches $len "2" or matches $len "3")
		{
			$basehold = $cmd
			$extenshold = $cmd
			head 1 $basehold
			tail 1 $extenshold
			return 0
		}
		$pref = $cmd
		loop ($fname) 
		{
			if (marked $fname) 
			{
				$front = $fname
				split 1 "." $front $back
				if (not matches $back "")
					$back=".$back"
				$cmd2 = ""
				$pref = $cmd
				while (split 1 $basehold $pref $suf)
				{
					$cmd2 = "$cmd2$pref$front"
					$pref = $suf
				}
				$cmd2 = "$cmd2$pref"
				$pref = $cmd2
				$cmd2 = ""
				while (split 1 $extenshold $pref $suf)
				{
					$cmd2 = "$cmd2$pref$back"
					$pref = $suf
				}
				$cmd2 = "$cmd2$pref"
				if (ExpandCommand($cmd2,"n") and $deselect)
					unmark $fname
			}
		}
		rescan "3"
	}
}

# Edit files that contain a string match.

EditMatching 
{
	local $fname, $cmd = "$editor ";
	write "Edit files matching? "
	if (not read $pat 40) return 0
	write "Edit files containing? "
	if (not read $string 40) return 0
	loop ($fname)
	{
		if (matches $fname /$pat/ and contains $fname $string)
			$cmd = "$cmd $fname"
	}
	if (not matches $cmd "$editor ") exec $cmd
	else echo "No matching files"
}

##############################################################
#							     #
#		Bits and Pieces				     #
#							     #
##############################################################

# Position cursor on a filename that matches a pattern

PSearch	
{
	write "Pattern? "
	if (read $pat 40)
		search /$pat/
}

# Apply a simple command that produces one line of output to the
# selected files, or the current file if none are selected. The
# types of commands I mean are things like "file", "wc", "sum", etc.

DoSimpleOp 
{
	if ( eval $pselcnt )
		exec "$op $psel | $pager"
	else 
	{
		execcatch "$op $pFile"
		echo $linebuff	
	}
}


# Simple expression calculator

Calc 
{
	local $expr = "", $res;
	write "Expression? "
	if (read $expr 60) 
	{
		expand $expr
		$res = eval $expr
		echo "$expr = $res"
	}
}

# Toggle the size of the directory windows

ChangeItem($name, $var, $inc)
{
	local $press, $cnt = "1";
	loop
	{
		write "Press [a digit and] `+' to increase $name, `-' to decrease $name"
		$press = ""
		if (not read $press 1) break
		if ($press in "0123456789") 
		{
			$cnt = $press;
			write "Press `+' to increase $name, `-' to decrease $name: "
			if (not read $press -1) break
			tail 1 $press
		}
		if ($press in "+") $var = eval "$var+$cnt"
		else if ($press in "-") $var = eval "$var-$cnt"
		else break
		invalidate; paint; sync
	}
}	

ChangeWidth	{ ChangeItem("width",$width,"2") }
ChangeHeight	{ ChangeItem("height",$height,"2") }
ChangeLeft	{ ChangeItem("left margin",$leftmargin,"1") }
ChangeTop	{ ChangeItem("top margin",$topmargin,"1") }

WindowChange
{
	local $opt = "";
	write "Change w(idth), h(eight), t(op margin) or l(eft margin? "
	if (read $opt 1)
	{
		if ($opt in "wW") ChangeWidth
		else if ($opt in "hH") ChangeHeight
		else if ($opt in "lL") ChangeLeft
		else if ($opt in "tT") ChangeTop
	}
}

# Search path for a file and print full pathname
# Currently this isn't bound to anything

whence 
{
	local $tmp2, $tmp;
	write "File name?"
	if (read $tmp 80) 
	{
		if (not inpath $tmp $tmp2) 
			write "Not in path"
		else
			write "Found at $tmp2"
	}
}

MarkAll 
{
	if ($DOSpatterns) mark /*.*/
	else mark /./
}

UnmarkAll 
{
	if ($DOSpatterns) unmark /*.*/
	else unmark /./
}

######################
# Directory Compares #
######################

markPair($f1,$f2) 
{
	mark $f1
	swap
	mark $f2
	swap
}

MarkSingle($pri $sec $key)
{
	local $pname, $sname;
	makepath $pname $ppath $pri
	makepath $sname $spath $sec
	if (compare mtime $pname $sname) 
	{
		# Mark the most recent
		if (+ compare mtime $sname $pname)
		{
			if ($key in "mM") 
			{
				swap; mark $sec; swap
			}
			else mark $pri
		} else
		{
			if (not $key in "mM")
			{
				swap; mark $sec; swap
			}
			else mark $pri
		}
	}
}

# Compare directory with multiple criteria

applyDirComp 
{
	local $fname, $sname, $tmp, $tmp2;
	UnmarkAll ; swap ; UnmarkAll ; swap
	loop ($fname) 
	{
		if (marked $fname) continue
		makepath $tmp $pPath $fname
		swap
		loop ($sname) 
		{
			makepath $tmp2 $pPath $sname
			if ($nameSame)
				if (compare name $fname $sname) continue
			if ($mtimeSame)
				if (compare mtime $tmp $tmp2) continue
IF_UNIX
			if ($atimeSame)
				if (compare atime $tmp $tmp2) continue
			if ($ownerSame)
				if (compare owner $tmp $tmp2) continue
			if ($groupSame)
				if (compare group $tmp $tmp2) continue
IF_ANY
			if ($sizeSame)
				if (compare size $tmp $tmp2) continue
			if ($contentsSame)
				if (compare contents $tmp $tmp2) continue
			echo "$tmp matches $tmp2"
			if (matches $markopt "1")
				markPair($sname,$fname)
			else if (matches $markopt "0")
				markSingle($sname, $fname, "m")
			else markSingle($sname, $fname, "l")
			if ($namesame)
				break
		}
		swap
	}
}

AddKeyName($title, $opt, $name) 
{
	if ($opt) $title = "$title $name"
}

CompareDirs 
{
	local $msg;
	$msg = "Comparing directories by"
	AddKeyName($msg $nameSame "Name")
	AddKeyName($msg $mtimeSame "MTime")
IF_UNIX
	AddKeyName($msg $atimeSame "ATime")
	AddKeyName($msg $ownerSame "Owner")
	AddKeyName($msg $groupSame "Group")
IF_ANY
	AddKeyName($msg $sizeSame "Size")
	AddKeyName($msg $contentsSame "Contents")
	$msg = "$msg..."
	echo $msg
	applyDirComp
	echo "Directory comparing done"
}

CompareDirectories 
{
	local $rtn, $oldentry = $helpentry;
	if (not ViewCheck) return 0
	$helpentry = "COMPFILEOPT"
	attribute "2"
	window "1" "10" "18" "60"
	box
	attribute "3"
	locate "2" "20"
	text "Compare Directories"
	attribute "2"
	locate "4" "8"
	text "Choose which attributes must match:"
	locate "6" "12"	; yntoggle $namesame
	locate "6" "18"	; text "File name"
	locate "7" "12"	; yntoggle $sizesame
	locate "7" "18"	; text "File size"
	locate "8" "12"	; yntoggle $mtimesame
	locate "8" "18"	; text "Modification time"
	locate "9" "12"	; yntoggle $contentsSame
	locate "9" "18"	; text "File Contents"
IF_UNIX
	locate "10" "12"; yntoggle $atimesame
	locate "10" "18"; text "Access time"
	locate "11" "12"; yntoggle $ownersame
	locate "11" "18"; text "Owner"
	locate "12" "12"; yntoggle $groupsame
	locate "12" "18"; text "Group"
IF_ANY
	locate "14" "2"	; text "Upon a match, mark"
	locate "14" "22"; toggle $markopt ":Most Recent:Both:Least Recent:"
	locate "16" "2"	; exittext "Start Compare"
	$rtn = procwin
	if (matches $rtn "Start" 5)
		CompareDirs
	$helpentry = $oldentry
}

# Prompt for and a script file function by name

runLink 
{
	local $cmd;
	write "Function? "
	if (read $cmd 80) "$cmd"
}

# Set the default message for the bottom of the screen

setVersionMessage 
{
	$message = "  Gram's Commander v$version (PL $patchlevel)                              Press ^H for menu  "
}

# Bind or unbind function keys (toggle)

functionBindings 
{
	if (not $fkeys) 
	{
		unbind [F0]
		unbind [F1]
		unbind [F2]
		unbind [F3]
		unbind [F4]
		unbind [F5]
		unbind [F6]
		unbind [F7]
		unbind [F8]
		unbind [F9]
		setVersionMessage
	} else 
	{
		bind [F1] to { help all}	"Show key binding help"
		bind [F2] to RenameFile		"Rename the current file"
		bind [F3] to PageFiles		"View the current file(s)"
		bind [F4] to EditFiles		"Edit the current file(s)"
		bind [F5] to CopyFiles		"Copy the current file(s) to other directory"
		bind [F6] to MoveFiles		"Move the currently selected files to other directory"
		bind [F7] to MakeDir		"Make a new directory"
		bind [F8] to DeleteFiles	"Delete the current file(s)"
		bind [F0] to { Quit }		"Exit from Gram's Commander"
		# Set the message for the bottom of the screen
		$message = "   F1=Help 2=Rename 3=View 4=Edit 5=Copy 6=Move 7=MkDir 8=Del 9=Info 10=Quit   "
	}
}

advancedBindings 
{
	if (not $expert) 
	{
IF_DOS
		unbind [M1]
		unbind [M2]
		unbind [M3]
		unbind [Mf]
IF_UNIX
		unbind ['L']
		unbind ['P']
		unbind ['R']
		unbind ['X']
		unbind ['~']
		unbind ['%']
IF_ANY
		unbind ['*']
		unbind ['^']
		unbind [^L]
		unbind [^K]
		unbind [^P]
		unbind [^O]
		unbind [^Q]
	} else 
	{
IF_DOS
		bind [M1] to { recmacro "0" }
			"Start/end macro 0 record"
		bind [M2] to { playmacro "0" }
			"Play back macro 0"
IF_UNIX
		bind ['P'] to CompareFiles	"Compare marked files to another directory"
		bind ['~'] to { recmacro "0" }
			"Start/end recording keystroke macro"
		bind ['%'] to { playmacro "0" }
			"Play back keystroke macro"
		bind ['R']
IF_DOS
		bind [Mf] 
IF_ANY
		    to { write "Filter pattern? "
		        if (read $pat 58) filter /$pat/
			else filter //
		} "Show only files matching pattern"
		bind ['*'] to { Dump }	
			"Show current values of all GC variables"
		bind ['^'] to PSearch		"Search for filename matching a pattern"
		bind [^L]  to {
			if ($viewer)
				if ($lock) $lock = "0"
				else $lock = "1"
			 } "Lock file in viewer"
	}
}

# Window Border workaround for xterms using fonts that don't support
# line drawing characters

IF_UNIX
SetBorder 
{
	# border workaround for xterms using fonts that don't
	# support line-drawing characters.
	if (not $border) 
	{
		hborder 0
		vborder 0
	} else 
	{
		hborder '-'
		vborder '|'
	}
}

IF_ANY

# Incremental file name search

incSearch
{
	local $pat, $oldpat;
	#Search 
	$pat = ""
	loop 
	{
		write "Hunt: "
		$oldpat = $pat
		paint;sync
		if (not read $pat -1) break
		if (matches $pat "") break # basically if ESC was pressed
		if (matches $pat $oldpat) break # if cursor key was pressed
		if ($DOSpatterns)
		{
			if (not search /$pat*.*/)
			{
				$pat = $oldpat
				beep
			}
		} else if (not search /^$pat/) 
		{
			$pat = $oldpat
			beep
		}
	}
}

###############
# SETUP FORMS #
###############

doDisplayOpts
{
	local $rtn, $oldentry = $helpentry,
		$oldcol = $iscolor, $oldbord = $border;
	$helpentry = "DISPLAYOPTS"
	attribute "2"
	window "1" "0" "13" "80"
	box
	attribute "3"
	locate "2" "27"
	text "gc3 Display Options Setup"
	attribute "2"
	locate "4" "2"	; yntoggle $dirsfirst
	locate "4" "8"	; text "Directories must be listed first"
	locate "5" "2"	; yntoggle $showhidden
	locate "5" "8"	; text "Show hidden files"
	locate "6" "2"; yntoggle $iscolor
	locate "6" "8"; text "Use colour attributes"
IF_UNIX
	locate "7" "2";  yntoggle $border
	locate "7" "8";  text "Use + and | to draw borders"
IF_ANY
	$rtn = procwin
IF_UNIX
	if (not matches $oldbord $border)
	{
		SetBorder
		clear
		paint
	}
IF_ANY
	$helpentry = $oldentry
	if (not matches $oldcol $iscolor) doTopAttrMenu
	
}

doCommandOpts
{
	local $rtn, $oldentry = $helpentry;
	$helpentry = "COMMANDOPTS"
	attribute "2"
	window "1" "0" "23" "80"
	box
	attribute "3"
	locate "2" "25"
	text "gc3 Command Options Setup"
	attribute "2"
	locate "4" "2"; yntoggle $Clear
	locate "4" "8"	; text "Clear screen before executing command"
	locate "6" "2"; yntoggle $deselect
	locate "6" "8"	; text "Clear selection after copy or command"
	locate "8" "2"; yntoggle $wait
	locate "8" "8"	; text "Prompt and wait for keypress after shell command"
IF_UNIX
	locate "10" "2"; yntoggle $saveoutput
	locate "10" "8"	; text "Tee output of commands to a file for recall"
IF_ANY
	attribute "3"
	locate "12" "30"; text "Command Suffixes"
	attribute "2"
	locate "14" "2"; edittext $sufc1 1
	locate "14" "5"; text "expands to prefix"
	locate "14" "24"; edittext $pref1 20
	locate "14" "48"; text " suffix"
	locate "14" "57"; edittext $suf1 20

	locate "15" "2"; edittext $sufc2 1
	locate "15" "5"; text "expands to prefix"
	locate "15" "24"; edittext $pref2 20
	locate "15" "48"; text " suffix"
	locate "15" "57"; edittext $suf2 20

	locate "16" "2"; edittext $sufc3 1
	locate "16" "5"; text "expands to prefix"
	locate "16" "24"; edittext $pref3 20
	locate "16" "48"; text " suffix"
	locate "16" "57"; edittext $suf3 20

	locate "17" "2"; edittext $sufc4 1
	locate "17" "5"; text "expands to prefix"
	locate "17" "24"; edittext $pref4 20
	locate "17" "48"; text " suffix"
	locate "17" "57"; edittext $suf4 20

	$expand = "n"
	$rtn = procwin
	$expand = "y"
	$helpentry = $oldentry
}

doOtherOpts
{
	local $rtn, $oldentry = $helpentry, $oldfkeys = $fkeys,
		$oldexpert = $expert, $olddospats = $dospatterns;
	$helpentry = "OTHEROPTS"
	attribute "2"
	window "1" "0" "23" "80"
	box
	attribute "3"
	locate "2" "27"
	text "gc3 Other Options Setup"
	attribute "2"
	locate "4"  "8"	;	text "Bind function keys"
	locate "6"  "8"	;	text "Bind `expert' functions"
	locate "8"  "8"	;	text "Directories can be selected"
	locate "10" "8"	;	text "Number lines in file viewer"
	locate "12" "8"	;	text "Delete files by moving to trash directory"
	locate "4"  "2"	;	yntoggle $fkeys
	locate "6"  "2"	;	yntoggle $expert
	locate "8"  "2"	;	yntoggle $dirselect
	locate "10" "2"	;	yntoggle $numberlines
	locate "12" "2" ;	yntoggle $usetrash
IF_DOS
	locate "14" "2";	text "Editor"
	locate "16" "2";	text "Pager"
	locate "18" "2";	text "Viewer"
	attribute "3"
	locate "14" "12";	edittext $editor 20
	locate "16" "12";	edittext $pager 20
	locate "18" "12";	edittext $viewprog 20

IF_UNIX
	locate "14" "8"	;	text "Follow symbolic links"
	locate "16" "8"	;	text "Use DOS-style file patterns"
	locate "18" "2";	text "Editor"
	locate "19" "2";	text "Pager"
	locate "20" "2";	text "Viewer"
	locate "14" "2";	yntoggle $followlinks
	locate "16" "2";	yntoggle $dospatterns
	locate "18" "12";	edittext $editor 20
	locate "19" "12";	edittext $pager 20
	locate "20" "12";	edittext $viewprog 20
	locate "18" "42";	text "Mail Reader"
	locate "18" "55";	edittext $mailread 20
	locate "19" "42";	text "News Reader"
	locate "19" "55";	edittext $newsread 20
IF_ANY
	$rtn = procwin
	if (not matches $oldfkeys $fkeys)
		functionBindings
	if (not matches $oldexpert $expert)
		advancedBindings
	if (not matches $olddospats $dospatterns)
	{
		if ($DOSpatterns) 
		{
			loadArea("UDOSActions", "NameActions", $nameacts)
			loadArea("UDOSActions", "TypeActions", $typeacts)
		} else 
		{
			loadArea("UNIXActions", "NameActions", $nameacts)
			loadArea("UNIXActions", "TypeActions", $typeacts)
		}
	}
	$helpentry = $oldentry
}

# top-level options menu #

doTopOptMenu 
{
	local $rtn, $oldentry = $helpentry;
	$helpentry = "TOPOPTMENU"
	attribute "2"
	window "1" "11" "5" "22"
	box
	locate "1" "2"
	action "Display Options" doDisplayOpts
	locate "2" "2"
	action "Command Options" doCommandOpts
	locate "3" "2"
	action "Other Options" doOtherOpts
	$rtn = procwin
	$helpentry = $oldentry
}

# top-level attribute menu #

doMonoAttr($idx, $blink, $bold, $uline, $inv)
{
	local $rtn, $oldentry = $helpentry, 
		$norm, $val = "0";
	if (not $inv) $norm = "y"
	else $norm = "n"
	$helpentry = "MONOATTR"
	attribute "2"
	window "1" "5" "9" "20"
	box
	locate "2" "2"; radio $norm
	locate "2" "6"; text "Normal"
	locate "3" "2"; radio $inv
	locate "3" "6"; text "Inverse"
	locate "4" "2"; yntoggle $blink
	locate "4" "6"; text "Blink"
	locate "5" "2"; yntoggle $uline
	locate "5" "6"; text "Underline"
	locate "6" "2"; yntoggle $bold
	locate "6" "6"; text "Bold"
	$rtn = procwin
	if ($blink) $val = eval "$val+1"
	if ($inv) $val = eval "$val+2"
	if ($bold) $val = eval "$val+4"
	if ($uline) $val = eval "$val+8"
  	attribute $idx is $val
	$helpentry = $oldentry
}

doMonoAttr1	{	doMonoAttr("0",$blink0,$bold0,$uline0,$inv0)	}
doMonoAttr2	{	doMonoAttr("1",$blink1,$bold1,$uline1,$inv1)	}
doMonoAttr3	{	doMonoAttr("2",$blink2,$bold2,$uline2,$inv2)	}
doMonoAttr4	{	doMonoAttr("3",$blink3,$bold3,$uline3,$inv3)	}

doTopAttrMenu 
{
	local $rtn, $oldentry = $helpentry;
	if ($isColor)
	{
		$helpentry = "COLORATTR"
		attribute "2"
		window "1" "14" "15" "40"
		attribute "3"
		box
		locate "1" "10"  ; text "Set Colour Attributes"
		attribute "2"
		locate "3" "2"  ; toggle $fg0 $colours
		locate "3" "14"	; text "Attribute 0 foreground"
		locate "4" "2"	; toggle $bg0 $colours
		locate "4" "14"	; text "Attribute 0 background"
		locate "6" "2"  ; toggle $fg1 $colours
		locate "6" "14" ; text "Attribute 1 foreground"
		locate "7" "2"	; toggle $bg1 $colours
		locate "7" "14"	; text "Attribute 1 background"
		locate "9" "2"	; toggle $fg2 $colours
		locate "9" "14"	; text "Attribute 2 foreground"
		locate "10" "2"	; toggle $bg2 $colours
		locate "10" "14"; text "Attribute 2 background"
		locate "12" "2"	; toggle $fg3 $colours
		locate "12" "14"; text "Attribute 3 foreground"
		locate "13" "2"	; toggle $bg3 $colours
		locate "13" "14"; text "Attribute 3 background"
		$rtn = procwin
		attribute "0" is $fg0 on $bg0
		attribute "1" is $fg1 on $bg1
		attribute "2" is $fg2 on $bg2
		attribute "3" is $fg3 on $bg3
	}
	else
	{
		$helpentry = "TOPATTRMENU"
		attribute "2"
		window "1" "14" "8" "20"
		box
		locate "2" "2"
		action "Mono Attribute 1" doMonoAttr1
		locate "3" "2"
		action "Mono Attribute 2" doMonoAttr2
		locate "4" "2"
		action "Mono Attribute 3" doMonoAttr3
		locate "5" "2"
		action "Mono Attribute 4" doMonoAttr4
		$rtn = procwin
	}
	$helpentry = $oldentry
}

#############
# Help Menu #
#############

BrowseManual
{ browse "gc3help.txt";paint }

KeyHelp { Help all }

doHelpMenu
{
	local $rtn, $oldentry = $helpentry;
	$helpentry = "HELPMENU"
	attribute "2"
	window "1" "37" "4" "26"
	box
	locate "1" "2"
	action "See Key Assignments" KeyHelp
	locate "2" "2"
	action "Browse Manual" BrowseManual
	$rtn = procwin
	$helpentry = $oldentry
}

#############
# Utilities #
#############

IF_UNIX

FileFinder
{
	local $rtn, $topdir = $ppath, $oldentry = $helpentry, $fcmd = "",
			$name = "", $size = "", $sizerel = "0", $mtime = "",
			$mtimerel = "0", $action = "0", $cmd = "", $conf = "n";
	$helpentry = "FILEFINDER"
	attribute "2"
	window "1" "0" "23" "80"
	box
	attribute "3"
	locate "1" "30"; text "File Finder"
	attribute "2"
	locate "3" "2"; text "Starting at directory"
	locate "3" "28"; edittext $topdir 50
	locate "5" "2"; text "Matching name"
	locate "5" "28"; edittext $name 40
	locate "7" "2"; text "Size in bytes must be"
	locate "7" "28"; toggle $sizerel ":exactly:at least:no more than:"
	locate "7" "45"; edittext $size 10
	locate "9" "2"; text "Days since last modified"
	locate "9" "28"; toggle $mtimerel ":exactly:more than:less than:"
	locate "9" "45"; edittext $mtime 10
	locate "11" "2"; text "Action"
	locate "11" "28"; toggle $action ":view names of matching files:view the files:execute a command:"
	locate "13" "2"; text "Command:"
	locate "13" "28"; edittext $cmd 40
	locate "15" "2"; text "Confirm each command"
	locate "15" "28"; yntoggle $conf
	locate "17" "30"; exittext "Start" 
	$rtn = procwin
	if (matches $rtn "Start")
	{
		$fcmd = "find $topdir"
		if (not matches $name "")
			$fcmd = "$fcmd -name #"$name#""
		if (not matches $size "")
		{
			$fcmd = "$fcmd -size "
			if (matches $sizerel "1") $fcmd = "$fcmd +"
			else if (matches $sizerel "2") $fcmd = "$fcmd -"
			$fcmd = cat $fcmd+$size+"c"
		}
		if (not matches $mtime "")
		{
			$fcmd = "$fcmd -mtime "
			if (matches $mtimerel "0") $fcmd = "$fcmd $mtime"
			else if (matches $mtimerel "1") $fcmd = "$fcmd +$mtime"
			else $fcmd = "$fcmd -$mtime"
		}
		if ($followlinks) $fcmd = "$fcmd -follow"
		if (matches $action "0")
			$fcmd = "$fcmd -print | $pager"
		else if (matches $action "1")
			$fcmd = "$fcmd -exec $viewprog {} \;"
		else if (not matches $cmd "")
		{
			if ($conf)
				$fcmd = "$fcmd -ok $cmd {} \;"
			else
				$fcmd = "$fcmd -exec $cmd {} \;"
		}
		exec $fcmd
	}
	$helpentry = $oldentry
}

readMail { exec "$mailread" }

readNews { exec "$newsread" }

doTalk {
	local $tmp, $oldentry = $helpentry, $rtn, $usr = "", $rem, $u = "0";
	execcatch "who -u"
	do 
	{
		$tmp = $linebuff
		split 1 "#w" $tmp $tmp
		if (not matches $tmp "") $usr = cat $usr + ":" + $tmp
	}
	while (nextline)
	$usr = cat $usr + ":"
	$helpentry = "TALKMENU"
	window "1" "10" "5" "67"
	attribute "2"
	box
	locate "1" "2"; text "Local users:"
	locate "1" "15"; toggle $u $usr
	locate "2" "2"; text "Remote user:"
	locate "2" "15"; edittext $rem 40
	locate "3" "2"; exittext "Start"
	$rtn = procwin
	if (matches $rtn "Start")
		if (matches $rem "")
			exec "talk ?"
		else exec "talk $rem"
	$helpentry = $oldentry
}

IF_ANY

emptytrash { exec "rm $trashdir$sep*" }

showtrash {
	if (access "$trashdir$sep#gc3trash.idx" "0")
		exec "$viewprog $trashdir$sep#gc3trash.idx"
}

undelete
{
	local $rtn, $tname = "0", $oname, $tlist = "";
	if (open "$trashdir$sep#gc3trash.idx")
	{
		do 
		{
			split -1 "#w" $linebuff $rtn
			head -1 $rtn # strip \n
			tail 25 $rtn # make sure it fits in window
			$tlist = cat $tlist+":"+$rtn
			#head 4 $linebuff
			#$tlist = cat $tlist+":"+$linebuff
		}
		while (nextline)
		$tlist = cat $tlist+":"
		attribute "2"
		window "10" "26" "6" "30"
		box
		locate "1" "2"
		toggle $tname $tlist
		locate "2" "2"
		exittext "Restore"
		$rtn = procwin
		if (matches $rtn "Restore")
		{
			if (open "$trashdir$sep#gc3trash.idx")
			{
				while (eval $tname) 
				{
					$tname = eval "$tname-1"
					nextline
				}
				$tname = $linebuff; head 4 $tname
				split -1 $sep $linebuff $oname
				copy "$trashdir$sep$tname" "$ppath$sep$oname"
				rescan "1"
				return 1
			}
		}
	}
	return 0
}

SubShell { clear; exec "$shell"; rescan "3" }
						
doUtilities
{
	local $rtn, $oldentry = $helpentry;
	$helpentry = "UTILMENU"
	attribute "2"
IF_UNIX
	if ($usetrash)
		window "1" "32" "12" "23"
	else
		window "1" "32" "9" "23"
IF_DOS
	if ($usetrash)
		window "1" "32" "8" "23"
	else
		window "1" "32" "5" "23"
IF_ANY
	box
	locate "1" "2"
	action "Run a Shell" SubShell
	locate "2" "2"
	action "Calculator" Calc
	locate "3" "2"
	action "Compare Directories" CompareDirectories
IF_UNIX
	locate "4" "2"
	action "File Finder" FileFinder
	locate "5" "2"
	action "Read Mail" readMail
	locate "6" "2"
	action "Read News" readNews
	locate "7" "2"
	action "Talk to Someone" doTalk
	$pos = "8"
IF_DOS
	$pos = "4"
IF_ANY
	if ($usetrash)
	{
		locate "$pos" "2"
		action "View Trash Index" showTrash
		$pos = eval "$pos+1"
		locate "$pos" "2"
		action "Undelete File" undelete
		$pos = eval "$pos+1"
		locate "$pos" "2"
		action "Empty Trash" emptyTrash
	}
	$rtn = procwin
	$helpentry = $oldentry
}

IF_ANY

###############
# WINDOW MENU #
###############

resortWindow($key $dir)
{
	if ($key in "NXSMA") $dir = "1"
	else if ($key in "nxsma") $dir = "0"
	if ($key in "0nN")
	{
		sortby $dir name
		$key = "0"
	} else if ($key in "1xX")
	{
		sortby $dir extens
		$key = "1"
	} else if ($key in "2sS")
	{
		sortby $dir size
		$key = "2"
	} else if ($key in "3mM")
	{
		sortby $dir mtime
		$key = "3"
	}
IF_UNIX
	else if ($key in "4aA")
	{
		sortby $dir atime
		$key = "4"
	}
IF_ANY
}

SortDir {
	local $w = $window, $key = "";
IF_DOS
	write "Sort by [mM]time [sS]ize [nN]ame or e[xX]tension? "
IF_UNIX
	write "Sort by [aA]time [mM]time [sS]ize [nN]ame or e[xX]tension? "
IF_ANY
	if (read $key 1)
	{
		tail 1 $w
		if ($w in "l")
		{
			$lsortkey = $key
			resortWindow($lsortkey $lsortdir) 
		} else
		{
			$rsortkey = $key
			resortWindow($rsortkey $rsortdir) 
		}
	}
}	

updateShow($showwhat)
{
	if (matches $showwhat "0") show none
	else if (matches $showwhat "1") show size
	else if (matches $showwhat "2") show mtime
IF_UNIX
	else if (matches $showwhat "3") show atime
	else if (matches $showwhat "4") show owner
	else if (matches $showwhat "5") show group
	else if (matches $showwhat "6") show perms
IF_ANY
}

doWindowMenu($left, $sortkey, $sortdir, $showwhat, $fpat, $depth, $root)
{
	local $rtn, $typ = "0", $oldentry = $helpentry;
	$helpentry = "WINDOWMENU"
	attribute "2"
	window "1" $left "10" "60"
	box
	locate "1" "2"; text "Window Type"
	if ($window in "v") $typ = "2"
	else if ($window in "t") $typ = "1"
	locate "1" "25"; toggle $typ ":Normal:Tree:Viewer:"
	locate "2" "2"; text "Sort Key"
IF_UNIX
	locate "2" "25"; toggle $sortkey
			":Name:Extension:Size:Modification Time:Access Time:";
IF_DOS
	locate "2" "25"; toggle $sortkey ":Name:Extension:Size:Modification Time:";
IF_ANY
	locate "3" "2"; text "Sort Direction"
	locate "3" "25"; toggle $sortdir ":Descending:Ascending:"
	locate "4" "2"; text "Show File Name and"
IF_DOS
	locate "4" "25"; toggle $showwhat ":None:Size:Modification Time:"
IF_UNIX
	locate "4" "25"; toggle $showwhat
		":None:Size:Modification Time:Access Time:Owner:Group:Permissions:"
IF_ANY
	locate "5" "2"; text "Filter Pattern"
	locate "5" "25"; edittext $fpat 16
	locate "6" "2"; text "Tree Root"
	locate "6" "25"; edittext $root 30
	locate "7" "2"; text "Tree Depth"
	locate "7" "25"; edittext $depth 4
	locate "8" "2"; action "Move/Resize Window" WindowChange
	$rtn = procwin
	if (matches $typ "0")
	{
		if ($window in "v") $viewer = "n"
		if ($tree) $tree = "0"
	   	if (not matches $fpat "") filter /$fpat/
		else filter //
		resortWindow($sortkey $sortdir)
		updateShow($showwhat)
	}
	else if (matches $typ "1")
	{
		if (not matches $depth $tree or not matches $root $spath)
		{
			if ($window in "v") $viewer = "n"
			cd $root
			$tree = $depth
		}
	}
	else if (matches $typ "2")
	{
		if ($tree) $tree = "0"
		if (not $window in "v") $viewer = "y"
	}
	$helpentry = $oldentry
}

doLeftWindow
{
	swap left; doWindowMenu("0", $lsortkey, $lsortdir, $lshow, $lfilter,
					$ldepth, $lroot);
}

doRightWindow
{
	swap right; doWindowMenu("20", $rsortkey, $rsortdir, $rshow, $rfilter,
					$rdepth, $rroot);
}

############
# MAIN MENU #
#############

doMainMenu
{
	local $rtn, $oldentry = $helpentry, $msg = $message;
	$message = "  Gram's Commander v$version (PL $patchlevel)                         Press ESC to exit menu  "
	echo $message
	$helpentry = "MAINMENU"
	attribute "2"
	window "0" "0" "1" "80"
	locate "0" "5"
	action "Left" doLeftWindow
	locate "0" "11"
	action "Options" doTopOptMenu
	locate "0" "20"
	action "Attributes" doTopAttrMenu
	locate "0" "32"
	action "Utilities" doUtilities
	locate "0" "43"
	action "Help" doHelpMenu
	locate "0" "50"
	action "Right" doRightWindow
	locate "0" "58"
	action "Quit" Terminate
	$rtn = procwin
	$helpentry = $oldentry
	$message = $msg
	echo $message
}

initAttributes
{
	if ($isColor)
	{
IF_UNIX
		$colours = ":Black:Red:Green:Yellow:Blue:Magenta:Cyan:White:"
		$fg0 = "7"; $bg0 = "4"
		$fg1 = "4"; $bg1 = "7"
		$fg2 = "7"; $bg2 = "1"
		$fg3 = "1"; $bg3 = "7"
IF_DOS
		$colours = ":Black:Blue:Green:Cyan:Red:Magenta:Brown:White:"
		$fg0 = "7"; $bg0 = "1"
		$fg1 = "1"; $bg1 = "7"
		$fg2 = "7"; $bg2 = "4"
		$fg3 = "4"; $bg3 = "7"
IF_ANY
		attribute "0" is $fg0 on $bg0
		attribute "1" is $fg1 on $bg1
		attribute "2" is $fg2 on $bg2
		attribute "3" is $fg3 on $bg3
	}
	else
	{
		$blink0 = "n"; $uline0 = "n"; $inv0 = "n"; $bold0 = "n";
		attribute "0" is "0"
		$blink1 = "n"; $uline1 = "n"; $inv1 = "y"; $bold1 = "n";
		attribute "1" is "2"
		$blink2 = "n"; $uline2 = "n"; $inv2 = "y"; $bold2 = "n";
		attribute "2" is "2"
		$blink3 = "n"; $uline3 = "n"; $inv3 = "y"; $bold3 = "y";
		attribute "3" is "6"
	}
}

##############################################################
#							     #
#		The default routine			     #
#							     #
# The default is to take the character, put in in as the     #
# first character of the $cmd variable, and then        #
# DoCommand to use the command line editor to get the rest   #
# of the command and run it.                                 #
##############################################################

gcdefault 
{
	DoCommand($ch)
}

# Post key processing; commented out as it doesn't do anything
# so why call it? Can be useful for some things (e.g. making the
# default message at the bottom of the screen dependent on the 
# file name at the cursor position).

#gcafterkey
#{ 
#}

##############################################################
#							     #
#		The initialise routine			     #
#							     #
##############################################################

gcinit 
{
	echo "Reinitialising variables and options..."
	# force rules to be used to get the editor, etc, if not
	# defined by environment
	$editor = ""
	$pager = ""
	$viewprog = ""
IF_UNIX
	$mailread = ""
	$newsread = ""
IF_ANY
	$namesame = "y" # set one criteria at least for dir comp
	$wascolor = ""
	$expand = "n"
IF_DOS
	$sufc2 = "@"; $pref2 = "rse "; $suf2 = ""
	$sufc3 = "!"; $pref3 = "rse"; $suf3 = "| $pager"
IF_UNIX
	$sufc2 = "@"; $pref2 = ""; $suf2 = "2>&1"
	$sufc3 = "!"; $pref3 = ""; $suf3 = "2>&1 | $pager"
IF_ANY
	$sufc1 = "|"; $pref1 = ""; $suf1 = "| $pager"
	$sufc4 = "<"; $pref4 = ""; $suf4 = "< $pfile"
	$expand = "y"
	$border = "n"
	$lsortkey = "0"
	$lsortdir = "1"
	$lshow = "1"
	$lfilter = ""
IF_UNIX
	lookup $home "HOME"
	$lroot = $home
	$rroot = $home
IF_DOS
	$lroot = "\"
	$rroot = "\"
IF_ANY
	$ldepth = "2"
	$rsortkey = "0"
	$rsortdir = "1"
	$rshow = "1"
	$rfilter = ""
	$rdepth = "2"
	$markopt = "1"
	$basehold = "&"
	$extenshold = "^"
}

##############################################################
#							     #
#		The startup routine			     #
#							     #
##############################################################

gcstart 
{
	local $tmp;
	$expand  = "y"
IF_UNIX
	SetBorder
IF_ANY
	clear
	metakey 27

	$mytemp = $tempname
	if (not matches $iscolor $wascolor)
	{
		$wascolor = $iscolor
		initAttributes
	}

	# Look up the EDITOR, PAGER and VIEWER environment variables

	if (lookup $tmp "EDITOR") $editor=$tmp
	if (lookup $tmp "PAGER") $pager=$tmp
	if (lookup $tmp "VIEWER") $viewprog=$tmp

IF_DOS
	$OS = "DOS"
	$sep = "\"
	$rulesep = ";"
	loadTables("gc3.rul")

	# Set the directory for trashed files

	$trashdir = "c:\gcbackup"

	# Bind the Alt- keys

	bind [Ma] to { MarkAll }	"Select all files"
	bind [Mb] to { browse "gc3help.txt";paint } 
		"Browse hypertext manual"
	bind [Mc] to CopyFiles		"Copy the current file(s) to other directory"
	bind [Md] to DeleteFiles	"Delete the current file(s)"
	bind [Me] to EditFiles		"Edit the current file(s)"
	bind [Mh] to { Help all }	"Show this help"
	bind [Mi] to InvertSelection	"Invert selection"
	bind [Mm] to MoveFiles		"Move the current file(s) to other directory"
	bind [Mn] to { UnmarkAll }	"Deselect all files"
	bind [Mp] to EditMatching	"Edit files containing string"
	bind [Mq] to { Terminate }	"Exit from Gram's Commander"
	bind [Ms] to SortDir		"Sort directory on new key"
	bind [Mt] to { $op="file"; DoSimpleOp }
		"Show the type of data in the file(s)"
	bind [Mv] to PageFiles		"View the current file(s)"
	bind [Mw] to { $op="wc"; DoSimpleOp }
		"Show byte, word and line count for current file(s)"
	bind [Mx] to { Terminate }	"Exit from Gram's Commander"

	# Bind the cursor pad keys

	bind [Ins] to Flip		"Toggle current selection state and move down"
	bind [CtlPgDn] to { DoCommand($nextcmd) }
		"Recall next command in history list"
	bind [CtlPgUp] to { DoCommand($prevcmd) }
		"Recall previous command in history list"
	keycode [*1] = 0x7700		# insert file name
        keycode [+0] = 0x7700 # Ctrl-Home
	bind [+0]  to { DoCommand("$pfile ") }
		"Enter command line editor with current file"

	bind [^Y] to { restore; getKeyPress; paint }
		"Review output of last command"

	# Miscellaneous ASCII key bindings

	bind ['+'] to SelectByPattern	"Select files using a DOS file pattern"
	bind ['-'] to DeselectByPattern	"Deselect files using a DOS file pattern"
IF_UNIX
	$OS = "UNIX"
	$sep = "/"
	$rulesep = ":"
	loadTables(".gc3rul")

	lookup $home "HOME"
	if (matches "$home" "") $home = "."
	lookup $term "TERM"

	# Set the directory for trashed files

	$trashdir = "$home/.gc3bak"

	# Key bindings

	bind ['A'] to { MarkAll }	"Select all files"
	bind ['B'] to { browse "help.txt";paint }
		"Browse hypertext manual"
	bind ['C'] to CopyFiles		"Copy the current file(s) to other directory"
	bind ['D'] to DeleteFiles	"Delete the selected files or directories"
	bind ['E'] to EditFiles		"Edit the current file(s)"
	bind ['F'] to { $op="file"; DoSimpleOp }
		"Show the type of data in the file(s)"
	bind ['H'] to KeyHelp	 	"Show this help"
	bind ['I'] to InvertSelection	"Invert selection"
	bind ['j'] to { Down }		"Move cursor down"
	bind ['k'] to { Up }			"Move cursor up"
	bind ['M'] to MoveFiles		"Move the current file(s) to other directory"
	bind ['N'] to { UnmarkAll }	"Deselect all files"
	bind ['Q'] to { Terminate }	"Exit from Gram's Commander"
	bind ['S'] to SortDir		"Sort directory on new key"
	bind ['T'] to EditMatching	"Edit files containing string"
	bind ['V'] to PageFiles		"View the selected file(s)"
	bind ['W'] to { $op="wc"; DoSimpleOp }
		"Show byte, word and line count for current file(s)"
	bind ['+'] to SelectByPattern
		"Select files using a regular expression"
	bind ['-'] to DeselectByPattern
		"Deselect files using a regular expression"

	bind [^U] to { PgUp }	"Move cursor to top line or up a page"
	bind [^D] to { PgDn }	"Move cursor to bottom line or down a page"
	bind [' '] to Flip		"Toggle current selection state and move down"
	bind [#19] to Flip		"Toggle current selection state and move down"
	keycode[#19] = 331 # Insert key

	# Command line editor setup
	# Command line history recan be done with ESC
	# followed by the ^B/^D...

	keycode [+0] = 2 # ESC-^B
	bind [+0] to { DoCommand($prevcmd) }
		"Recall previous command in history list"
	keycode [+1] = 4 # ESC-^D
	bind [+1] to { DoCommand($nextcmd) }
		"Recall next command in history list"

	bind [^F]  to { DoCommand("$pfile ") }
		"Enter command line editor with current file"
	keycode [*1] = 6		# insert file name is ^F

	keycode [*2] = 12		# Move to start of line is ^L
	keycode [*3] = 18		# Move to end of line is ^R
	keycode [*6] = 127		# Delete under cursor is Del
#	keycode [*7] = 8		# Delete left of cursor is Backspace
	keycode [*8] = 331		# Togle Ins/overstrike is Ins
	keycode [*9] = 27		# clear whole line is ESC
	keycode [*10] = 5		# erase from start of line is ^E
	keycode [*11] = 11		# kill to end of line is ^K
	keycode [*12] = 24		# del from prev word to cursor is ^X
	keycode [*13] = 23		# delete to start of next word is ^W
	keycode [*14] = 16		# move cursor to previous word is ^P
	keycode [*15] = 14		# move cursor to next word is ^N
	keycode [*16] = 2		# reprevious is ^B
	keycode [*17] = 4		# renext is ^D
	bind [^Y] to { exec "$viewprog $mytemp" }
		"Review output of last command"
IF_ANY
	if (not access $trashdir "0") execcatch "mkdir $trashdir"

	# Bindings common to DOS and UNIX

	bind ['?'] to incSearch
		"Start incremental file name search"
	bind ['='] to Calc
		"Read and evaluate an expression"
	bind ['`'] to WindowChange
		"Change the size or position of the active window"
	bind [','] to { 
		if (ViewCheck) { swap; cd "$spath"; swap}
	     } "Set secondary window to have same path as current window"
	bind ['$'] to SubShell "Spawn a shell"
	bind [^A]  to { ProcFiles }
		"Apply a command to all the marked files in turn"
	bind [^R]  to { rescan "3"; rescan "3"; invalidate }
		"Reread directories and repaint screen"
	bind [^I]  to { swap } "Activate other window"
	bind [^M]  to FileDep		"Do file dependent action on current file"

	# Bind any additional functions

	if ($fkeys) functionBindings
	else setVersionMessage
	if ($expert) advancedBindings
	# Set up the default help
	$helpfile = "gc3help.txt"
	$helpentry = "CMDLNED"
	bind [^B] to BrowseManual "Browse hypertext manual"
	bind [^H] to doMainMenu "Call up main menu"
}


